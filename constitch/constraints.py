from typing import Optional
from fractions import Fraction
import dataclasses
import itertools
import enum
import math
import warnings

import numpy as np
import sklearn.linear_model

from . import utils

class ConstraintType(enum.Enum):
    NORMAL = 'normal'
    MODELED = 'modeled'
    IMPLICIT = 'implicit'



class Constraint:
    """ A class to represent the pixel offset between two images in a composite.

    The Constraint is an important component of the ConStitch algorithm, and converting
    from global positions of images to a set of constraints between images and back
    is the main algorithm used to stitch image sets.

    It is not normally necesarry to instantiate Constraint objects directly, instead
    they are created from the existing image positions with CompositeImage.constraints
    or by calculating new constraints with the Constraint.calculate or ConstraintSet.calculate
    functions.

    The class ConstraintSet is used as a container to manipulate and filter large collections
    of constraints

    Fields:
        composite (Composite): A reference to the composite that holds the images of this constraint

        index1 (int): The index in the composite to the first image.
            This index will always be less than index2, if index1 > index2 then
            the constraint should have been created swapping index1 and index2
        index2 (int): The index in the composite to the second image

        dx (int): X coordinate offset from image1 to image2
            This offset is measured from the pixel at 0,0 of image1
            to the pixel at 0,0 of image2, or put another way the
            offset is measured from the position of the box of the first image
            to the position of the box of the second image
        dy (int): Y coordinate offset from image1 to image2
            Measured the same way as dx, from the 0,0 pixel in image1
            to the 0,0 pixel in image2, or from box1.position to box2.position

        score (float): A value that relatively scores how well the alignment is
            This score is generated by the alignment algorithm, to allow for filtering
            and weighting of constraints based on it. Constraints calculated
            from existing image positions will have a score of None
        
        error (int): The uncertanty of the specified alignment
            This error value is treated as an uncertanty, saying the true alignment
            is equal to (dx ± error, dy ± error). This is typically zero
            unless the images were downscaled, and the uncertanty of original
            image positions can be specified by the user. When calculating new constraints
            only offsets that fall within these bounds are considered, see section1 and section2
            for more information on how 
    """

    def __init__(self, composite, index1=None, index2=None, dx=None, dy=None, score=None, error=None, type=ConstraintType.NORMAL):
        if isinstance(composite, Constraint):
            composite, index1, index2 = composite.composite, composite.index1, composite.index2
        else:
            assert index1 is not None and index2 is not None, "index1 and index2 are only optional when constructing from another constraint"

        self.composite = composite
        self.index1 = index1
        self.index2 = index2

        if dx is None or dy is None:
            type = ConstraintType.IMPLICIT
            dx, dy = self.box2.position[:2] - self.box1.position[:2]
            if error is None: error = self.composite.positional_error * 2

        self.dx = dx
        self.dy = dy
        self.score = score
        self.error = error
        self.type = ConstraintType(type)

    def to_obj(self):
        return dict(
            index1=self.index1, index2=self.index2,
            dx=int(self.dx), dy=int(self.dy),
            score=float(self.score) if self.score is not None else None,
            error=self.error,
            type=self.type.value,
        )

    def __str__(self):
        params = dict(dx=self.dx, dy=self.dy, score=self.score, error=self.error)
        return "Constraint({}, {}{})".format(self.index1, self.index2,
            ", ".join([''] + ["{}={}".format(name, val) for name, val in params.items() if val is not None]))

    def __repr__(self):
        return self.__str__()

    @property
    def modeled(self):
        return self.type == ConstraintType.MODELED
    @property
    def implicit(self):
        """ Whether or not this constraint is implicit, meaning it was calculated
        from existing image positions and was not calculated using an alignment
        algorithm
        """
        return self.type == ConstraintType.IMPLICIT

    @property
    def pair(self):
        """ The two indices of the images in the composite as a tuple
        """
        return (self.index1, self.index2)

    @property
    def box1(self):
        """ Retrieves the box of image1 from the composite,
        equivalent to self.composite.boxes[self.index1]
        """
        return self.composite.boxes[self.index1]
    @property
    def box2(self):
        """ Retrieves the box of image2 from the composite,
        equivalent to self.composite.boxes[self.index2]
        """
        return self.composite.boxes[self.index2]

    @property
    def image1(self):
        """ Retrieves the image1 from the composite,
        equivalent to self.composite.images[self.index1]
        """
        return self.composite.images[self.index1]
    @property
    def image2(self):
        """ Retrieves the image2 from the composite,
        equivalent to self.composite.images[self.index2]
        """
        return self.composite.images[self.index2]

    @property
    def pixel_scale_ratio(self):
        """ The difference in pixel scale between image1 and image2. For example
        if image2 was taken with 2x the magnification and thus each pixel is
        half the size of each pixel in image1, the scale ratio would be 2 / 1
        as image2 would need to be scaled up by 2 to have the same pixel size.
        The ratio is returned as a fractions.Fraction for the x and y axes.
        """
        scale_ratio_x = Fraction(self.image2.shape[0], self.box2.size[0]) / Fraction(self.image1.shape[0], self.box1.size[0])
        scale_ratio_y = Fraction(self.image2.shape[1], self.box2.size[1]) / Fraction(self.image1.shape[1], self.box1.size[1])
        return scale_ratio_x.limit_denominator(), scale_ratio_y.limit_denominator()

    @property
    def resized_image1(self):
        """ Retrieves the first image of the constraint, resizing it so that
        the scale of pixels between image1 and image2 is the same.
        This may require computing the resized image, but it will be cached
        in the composite and any subsequent calls will not require any calculation
        """
        ratio_x, ratio_y = self.pixel_scale_ratio
        return self.composite.resized_image(self.index1, ratio_x.denominator, ratio_y.denominator)

    @property
    def resized_image2(self):
        """ Retrieves the first image of the constraint, resizing it so that
        the scale of pixels between image1 and image2 is the same.
        This may require computing the resized image, but it will be cached
        in the composite and any subsequent calls will not require any calculation
        """
        ratio_x, ratio_y = self.pixel_scale_ratio
        return self.composite.resized_image(self.index1, ratio_x.numerator, ratio_y.numerator)

    @property
    def section1(self):
        """ Returns the section of image1 relevant for alignment, that is the
        section of image1 that overlaps with image2, expanded to include self.error,
        and resized so that both sections have the same pixel scale.
        If error is infinite or None this will be the same as self.resized_image1.
        Usually used by the alignment algorithm when calculating new constraints,
        see the docs for Aligner for more info
        """
        x1, x2, y1, y2 = self.section1_bounds
        section = self.resized_image1[x1:x2,y1:y2]

        return self.image1[x1:x2,y1:y2]

    @property
    def section2(self):
        """ Returns the section of image2 relevant for alignment, that is the
        section of image2 that overlaps with image1, expanded to include self.error,
        and resized so that both sections have the same pixel scale.
        If error is infinite or None this will be the same as self.resized_image1.
        """
        x1, x2, y1, y2 = self.section2_bounds
        return self.resized_image2[x1:x2,y1:y2]

    @property
    def section1_bounds(self):
        ratio_x, ratio_y = self.pixel_scale_ratio
        scale_x, scale_y = ratio_x.denominator, ratio_y.denominator

        if self.error is None or self.error == math.inf:
            return 0, self.box1.size[0] * scale_x, 0, self.box1.size[1] * scale_y

        expand = self.error

        x1 = max(0, self.dx - expand) * scale_x
        x2 = min(self.box1.size[0], self.box2.size[0] + self.dx + expand) * scale_x
        y1 = max(0, self.dy - expand) * scale_y
        y2 = min(self.box1.size[1], self.box2.size[1] + self.dy + expand) * scale_y

        return x1, x2, y1, y2

    @property
    def section2_bounds(self):
        ratio_x, ratio_y = self.pixel_scale_ratio
        scale_x, scale_y = ratio_x.numerator, ratio_y.numerator

        if self.error is None or self.error == math.inf:
            return 0, self.box2.size[0] * scale_x, 0, self.box2.size[1] * scale_y

        expand = self.error

        x1 = max(0, -self.dx - expand) * scale_x
        x2 = min(self.box2.size[0], self.box1.size[0] - self.dx + expand) * scale_x
        y1 = max(0, -self.dy - expand) * scale_y
        y2 = min(self.box2.size[1], self.box1.size[1] - self.dy + expand) * scale_y

        return x1, x2, y1, y2

    @property
    def overlap_x(self):
        """ The overlap of the two images across the x axis, in pixels
        """
        return min(self.box1.size[0] - self.dx, self.box2.size[0], self.box2.size[0] + self.dx, self.box1.size[0])
    @property
    def overlap_y(self):
        """ The overlap of the two images across the y axis, in pixels
        """
        return min(self.box1.size[1] - self.dy, self.box2.size[1], self.box2.size[1] + self.dy, self.box1.size[1])
    @property
    def overlap(self):
        """ The overlap of the two images, in total number of pixels. If the images
        don't overlap, it will be negative
        """
        overlaps = self.overlap_x, self.overlap_y
        if overlaps[0] < 0 and overlaps[1] < 0: return -overlaps[0] * overlaps[1]
        return overlaps[0] * overlaps[1]

    @property
    def overlap_ratio_x(self):
        """ The overlap of the two images across the x axis, as a ratio of the image size.
        If the images are different sizes it is a ratio with the smaller images size.
        """
        return self.overlap_x / min(self.box1.size[0], self.box2.size[0])
    @property
    def overlap_ratio_y(self):
        """ The overlap of the two images across the y axis, as a ratio of the image size.
        If the images are different sizes it is a ratio with the smaller images size.
        """
        return self.overlap_y / min(self.box1.size[1], self.box2.size[1])
    @property
    def overlap_ratio(self):
        """ The overlap of the two images, as a ratio of the number of pixels overlapping
        over the maximum possible number of pixels overlapping
        """
        return self.overlap / min(self.box1.size.prod(), self.box2.size.prod())

    @property
    def touching(self):
        """ True if the images are either overlapping (self.overlap > 0) or touching
        along the x or y axis (self.overlap_x > 0 or self.overlap_y > 0)
        """
        return self.overlap >= 0 and (self.overlap_x > 0 or self.overlap_y > 0)

    @property
    def length(self):
        """ The length of the offset between images, sqrt(dx^2 + dy^2)
        """
        return (self.dx ** 2 + self.dy ** 2) ** 0.5

    @property
    def difference(self):
        """ The difference between the offset specified in this constraint and the
        difference in positions of the images currently, from self.box1 and self.box2.
        If this constraint was calculated using an alignment algorithm this is the
        correction the alignment algorithm applied, and if this is after the global
        positions of the images have been solved then this is the error present when
        solving for the positions
        """
        return (self.dx, self.dy) - (self.box2.position[:2] - self.box1.position[:2])

    def calculate(self, aligner=None, executor=None):
        """ Calculates a new constraint using the specified alignment algorithm.
        More information on how alignment is performed can be found at constitch.alignment
        """
        return self._calculate_future(aligner, executor).result()

    def _calculate_future(self, aligner=None, executor=None):
        aligner = aligner or self.composite.aligner
        executor = executor or self.composite.executor
        #newconst = aligner.align(image1=self.image1, image2=self.image2, shape1=self.box1.size, shape2=self.box2.size, previous_constraint=self)
        future = executor.submit(_align_job, aligner, constraint=self)
        #future = executor.submit(_align_job, aligner, image1=self.image1, image2=self.image2, shape1=self.box1.size, shape2=self.box2.size, previous_constraint=self)
        #self.composite.add_constraint(newconst)
        return future

    def new(self, dx=None, dy=None, section_dx=None, section_dy=None, score=None, error=None, type=None):
        """ Creates a new constraint between the images of this one. Normally used
        by alignment algorithms when they calculate a
        new constraint

        Params:
            dx, dy, score, error, type: See docs for Constraint.__init__()

            section_dx (int): The X offset between the two sections, self.section1 and self.section2
                Aligning is normally performed on self.section1 and self.section2 as
                they are the sections that are overlapping given the current offset and error.
                This can cause problems as sections may be sliced or resized, so dx and dy
                can be specified here and will be converted into the actual dx and dy
            section_dy (int): The Y offset between the two sections
                Same as section_dx, this is to specify the calculate the offset between self.section1
                and section2, given any slicing or resizing that has happened
        """

        if section_dx is not None:
            dx = self.section1_bounds[0] - self.section2_bounds[0] + section_dx
            dy = self.section1_bounds[2] - self.section2_bounds[2] + section_dy

        return Constraint(self, dx=dx, dy=dy, score=score, error=error, type=type)


def _align_job(aligner, **kwargs):
    return aligner.align(**kwargs)


class ConstraintFilter:
    """ A class that represents a filter on constraints. Can be a threshold
    on a attribute of constraints, eg ConstraintFilter(min_score=0.5),
    a required value or constraint type, eg ConstraintFilter(touching=True, implicit=True),
    or a custom function that returns a bool, eg ConstraintFilter(lambda const: const.box1.position[0] < 5000)

    Filters can be created and combined with & or | and passed to ConstraintSet.filter() to select for
    specific constraints.
    """
    def __init__(self, obj=None, **kwargs):
        """ A filter can be constructed in multiple ways:
        
        ConstraintFilter(params)
        ConstraintFilter(**kwargs)

            Constructing with a dictionary of parameters. Each entry in the
            dictionary or keyword parameter must be an attribute of a Constraint
            instance, optionally prepended with min_ or max_.
            When filtering, the specified attribute will be retrieved from each constraint
            and compared to the value passed here. If prepended with min_ values greater or equal
            will be kept and if prepended with max_ values less than or equal will be kept,
            otherwise only values that are equal are kept.

            For example, the filter ConstraintFilter(min_score=0.5) will keep constrains where
            constraint.score >= 0.5 is True.

            When multiple parameters are specified, only constraints that match all parameters
            will be kept. If you want to match either parameter, create multiple filters and combine
            them, eg ConstraintFilter(touching=True) | ConstraintFilter(min_score=0.5)

        ConstraintFilter(func)

            Constructing from a function. The passed function is evaluated for each constraint,
            if True the constraint is kept. This has the same behaviour as the builtin filter()
        """
        self.func = None
        self.mins = {}
        self.maxes = {}
        self.equals = {}

        if isinstance(obj, dict):
            self.fromdict(obj)
        elif callable(obj):
            self.func = obj

        self.fromdict(kwargs)

    def __str__(self):
        parts = []
        parts.extend('{} >= {}'.format(name, val) for name, val in self.mins.items())
        parts.extend('{} == {}'.format(name, val) for name, val in self.equals.items())
        parts.extend('{} <= {}'.format(name, val) for name, val in self.maxes.items())
        return 'ConstraintFilter({})'.format(', '.join(parts))

    def fromdict(self, params):
        for name, val in params.items():
            if name[:4] == 'min_':
                self.mins[name[4:]] = val
            elif name[:4] == 'max_':
                self.maxes[name[4:]] = val
            else:
                self.equals[name] = val

    def __call__(self, constraint):
        """ Evaluates the filter on a constraint.
        Returns whether or not the constraint should be kept.
        """
        #print (' running filter', self, constraint, constraint.overlap_ratio)
        if self.func is not None and not self.func(constraint):
            return False

        for name, val in self.mins.items():
            if getattr(constraint, name) < val: return False

        for name, val in self.maxes.items():
            if getattr(constraint, name) > val: return False

        for name, val in self.equals.items():
            if getattr(constraint, name) != val: return False

        #print ('    True')
        return True

    def __and__(self, other):
        """ Combines two filters, creating a new filter that evaluates
        to True when both others evaluate to True
        """
        mins = self.mins.copy()
        for name, val in other.mins.items():
            mins[name] = max(mins.get(name, val), val)

        maxes = self.maxes.copy()
        for name, val in other.maxes.items():
            maxes[name] = max(maxes.get(name, val), val)

        equals = self.equals.copy()
        for name, val in other.equals.items():
            if name in equals and val != equals[name]: #short circuit to always false
                return ConstraintFilter(lambda constraint: False)
            equals[name] = val

        func = self.func
        if other.func is not None:
            if func is None:
                func = other.func
            else:
                func = lambda constraint, filter1=func, filter2=other.func: filter1(constraint) and filter2(constraint)

        newfilter = ConstraintFilter()
        newfilter.func = func
        newfilter.mins = mins
        newfilter.maxes = maxes
        newfilter.equals = equals
        return newfilter

    def __or__(self, other):
        """ Combines two filters, creating a new filter that evaluates
        to True when either other filters evaluate to True
        """
        return ConstraintFilter(lambda constraint, filter1=self, filter2=other: filter1(constraint) or filter2(constraint))

    def alwaystrue(self):
        return self.func is None and len(self.mins) == 0 and len(self.maxes) == 0 and len(self.equals) == 0

#"""
class ConstraintSet:
    """ A class that stores a set of constraints

    Many important algorithms when stitching revolve around manipulating
    sets of constraints, thus we have the class ConstraintSet to represent
    collections of Constraints and filter/manipulate them. A ConstraintSet
    behaves mostly like a dictionary mapping pairs of images to Constraints.

    ConstraintSets are normally created from CompositeImage.constraints
    or ConstraintSet.calculate, but they can be instantiated with any
    sequence of Constraints

    """
    def __init__(self, constraints=None):
        self.constraints = {}
        if constraints:
            self.add(constraints)

    @property
    def composite(self):
        """ The composite that contains all the images of the constraints of this
        set. If constraints from a different constraint are added, an error will be
        raised. If this instance contains no constraints this will return None
        """
        if len(self.constraints):
            return next(iter(self.constraints.values())).composite

    def debug(self, *args, **kwargs):
        """ A shorthand for self.composite.debug
        """
        if self.composite:
            self.composite.debug(*args, **kwargs)

    def progress(self, iter, **kwargs):
        """ A shorthand for self.composite.progress
        """
        if self.composite:
            return self.composite.progress(iter, **kwargs)
        return iter

    def add(self, other):
        """ Add constraints to this set

        If a constraint between the same images is already present, the constraint
        with the lower error is kept and the other is removed.
        In the case of equal errors the new constraint is kept

        Args:
            other (Constraint or sequence of Constraints): Constraint or Constraints to add

        Raises:
            ValueError: The constraint(s) to be added are from a different CompositeImage
        """
        if isinstance(other, Constraint):
            self._add_single(other)
        else:
            for const in self._constraint_iter(other):
                self._add_single(const)

    def remove(self, other):
        """ Remove constraints from this set

        Args:
            other (Constraint, (int, int) or sequence of either):
                The constraints or pairs to be removed

        Raises:
            KeyError: The specified constraint does not exist
        """
        if isinstance(other, Constraint) or (type(other) == tuple and len(other) == 2):
            self._remove_single(other)
        else:
            for const in self._constraint_iter(other):
                self._remove_single(const)

    def merge(self, other, *others):
        """ Returns a new ConstaintSet with combined constraints from this and other sets

        As with add(), if constraints between the same image pair are present in both sets
        then the constraint with the lowest error is kept, with ties defaulting to constraints in the
        last passed in set
        
        Args:
            other (Constraint or sequence of Constraints): Constraint or Constraints to
                merge with new set

        Raises:
            ValueError: The constraints to be merged are from a different ConstraintImage
        """
        new_set = ConstraintSet()
        new_set.add(self)
        new_set.add(other)
        for another in others:
            new_set.add(another)
        return new_set

    def filter(self, obj=None, limit=None, random=False, sorted_by=None, **kwargs):
        """ Returns a new ConstraintSet with only constraints that are
        matching the specified filter.

        Either a ConstraintFilter instance can be passed in or an object that
        can be converted into a filter, ie a dictionary or a set of keyword arguments.
        See ConstraintFilter for the full documentation on creating a filter.

        Args:
            obj: The filter or object to be converted into a filter. Can be many types:
                If it is a ConstraintFilter or a callable it is applied as the filter
                If it is a numpy bool array, it is used to filter constraint, mapping with
                the order of self.constraints
                If it is a set or list of pairs of indices, only constraints for those pairs are kept
            limit (int): The maximum number of constraints returned
            random (bool): If true the constraints are shuffled
                Normally used in conjunction with the limit argument to select a random
                sample of the constraints
            sorted_by (function or str): key to sort constraints on
                Either a function that can be passed as a key to sorted() or a string
                that is an attribute of a constraint. Used to sort the constraints, normally
                used with the limit argument
            kwargs: Any keyword arguments are passed to a new ConstraintFilter() constructor
                and applied as a filter

        Returns:
            A new ConstraintSet with the filtered Constraints
        """
        filters = ConstraintFilter()
        if isinstance(obj, ConstraintFilter):
            filters = obj
        elif isinstance(obj, np.ndarray) and obj.dtype == bool:
            return ConstraintSet(const for const, valid in zip(self._constraint_iter(), obj) if valid)
        elif isinstance(obj, set) or isinstance(obj, list):
            return ConstraintSet(self.constraints[pair] for pair in obj)
        elif obj is not None:
            filters = ConstraintFilter(obj)

        if kwargs:
            filters = filters & ConstraintFilter(kwargs)

        iterable = self._constraint_iter()
        if random:
            iterable = self._random_iter()
        if sorted_by is not None:
            iterable = self._sorted_iter(sorted_by=sorted_by)

        if limit is not None:
            iterable = itertools.islice(iterable, limit)

        newset = ConstraintSet(filter(filters, iterable))

        return newset

    def find(self, obj=None, **kwargs):
        """ Returns the first constraint to match a filter

        Uses the same interface as self.filter but returns the first
        constraint that matches the filter
        """
        return next(iter(self.filter(obj, limit=1, **kwargs)))

    def neighboring(self, constraint, depth=1):
        """ Returns a new ConstraintSet containing only constraints that
        are connected to an initial constraint or image

        The starting location is specified by passing either a constraint, a
        image index, or a sequence of either. Constraints are added by BFS to
        the requested depth. Any constraints provided as a starting location
        are not included in the resulting set
        """
        indices = set()
        exclude = set()

        def make_indices(constraint):
            if isinstance(constraint, Constraint):
                indices.update(set(constraint.pair))
                exclude.add(constraint.pair)
            elif type(constraint) == int:
                indices.add(constraint)
            else:
                for const in constraint:
                    make_indices(const)

        make_indices(constraint)

        for i in range(depth-1):
            new_indices = set()
            for const in self:
                if const.index1 in indices:
                    new_indices.add(const.index2)
                if const.index2 in indices:
                    new_indices.add(const.index1)
            indices.update(new_indices)

        return self.filter(lambda const: const.pair not in exclude and (const.index1 in indices or const.index2 in indices))

    def __iter__(self):
        """ Iterates through all constraints in this set
        """
        return iter(self.constraints.values())
        #return iter(const_list[0] for const_list in self.constraints.values())

    def __len__(self):
        return len(self.constraints)

    def __getitem__(self, pair):
        return self.constraints[pair]
        #return self.constraints[pair][0]

    def __contains__(self, obj):
        """ Tests if a Constraint or a pair is contained
        """
        if isinstance(obj, Constraint):
            return obj.pair in self.constraints and obj is self.constraints[obj.pair]
        else:
            return obj in self.constraints

    def keys(self):
        return self.constraints.keys()

    def values(self):
        return self.constraints.values()
        #return (const_list[0] for const_list in self.constraints.values())

    def items(self):
        return self.constraints.items()
        #return ((pair, const_list[0]) for pair, const_list in self.constraints.items())


    ATTRS = ['dx', 'dy', 'score', 'error', 'overlap', 'overlap_x', 'overlap_y', 'overlap_ratio', 'overlap_ratio_x', 'overlap_ratio_y', 'size', 'difference']
    def __getattr__(self, name):
        """ Some attributes of Constraint can be accessed from a ConstraintSet, returned as a numpy
        array of the values for all constraints, in the order of self.keys()
        """
        if name not in self.ATTRS:
            return getattr(super(), name)
        return np.array([getattr(const, name) for const in self])

    def neighborhood_difference(self, constraint):
        """ A metric that measures how well this constraint matches the image
        positions, taking into account neighboring constraints.
        """
        touching_constraints = self.neighboring(constraint)
        diffs = touching_constraints.difference
        max_diff = np.max(np.linalg.norm(diffs))
        curdiff = np.linalg.norm(constraint.difference)
        if max_diff > curdiff:
            curdiff = 0
        return curdiff

    def calculate(self, aligner=None, executor=None):
        """ Calculates new constraints using an alignment algorithm

        For every constraint the provided aligner is invoked to calculate
        a new constraint. See constitch.alignment for more information on
        alignment.

        Args:
            aligner (constitch.Aligner): default self.composite.aligner
                The aligner that is used to calculate the new constraints
            executor (concurrent.futures.Executor): default self.composite.executor
                A thread or process pool instance to parallelize the computation,
                as some aligners can be quite slow
        """
        futures = [const._calculate_future(aligner=aligner, executor=executor) for const in self]
        newset = ConstraintSet(future.result() for future in self.progress(futures))
        self.debug("Calculated", len(futures), "new constraints")
        return newset

    def fit_model(self, model=None, outliers=False, random_state=12345):
        """ Fits a linear model to the constraints in this set

        This learns the motion of the microscope stage, which can be used to fill in
        constraints in areas where there are not enough features to align.

        The model is trained on the relation between the offset in image positions,
        that is box2.position - bos1.position, and the offset specified in dx and dy.

        Args:
            model (sklearn base model): default constitch.SimpleOffsetModel()
                The linear model to train, it should be a sklearn model class, meaning
                it has a fit and predict method. The fit method is called
                with X as a 4 column matrix containing the x and y positions of image1 and image2
                for all constraints, and y as a 2 column matrix with dx and dy for all constraints
            outliers (bool): Whether to use an outlier resistant model
                If set to True the provided model is wrapped in sklearn.linear_model.RANSACRegressor,
                and the inlier and outlier classifications are added onto the returned
                result as result.inliers and result.outliers. These are new ConstraintSets
                containing only the inliers and outliers that the model classified
            random_state: the random state passed to RANSACRegressor when outliers=True

        Returns:
            An Aligner class that can be used to calculate new constraints, using
            the linear model fit here.
        """
        from . import stage_model
        model = model or stage_model.SimpleOffsetModel()

        if outliers:
            model = sklearn.linear_model.RANSACRegressor(model,
                    min_samples=4,
                    max_trials=1000,
                    random_state=random_state)

        est_poses = []
        const_poses = []
        indices = []
        for constraint in self:
            est_poses.append(np.concatenate([constraint.box1.position, constraint.box2.position]))
            const_poses.append((constraint.dx, constraint.dy))
            indices.append(constraint.pair)

        est_poses, const_poses = np.array(est_poses), np.array(const_poses)
        indices = np.array(indices)

        model.fit(est_poses, const_poses)
        #print (model.estimator.model.coef_)

        aligner = stage_model.StageModelAligner(model.estimator_ if outliers else model)

        if outliers:
            self.debug ('Filtered out', np.sum(~model.inlier_mask_), 'constraints as outliers')

            if np.mean(model.inlier_mask_.astype(int)) < 0.8:
                warnings.warn("Stage model filtered out over 20% of constraints as outilers."
                        " It may have hyperoptimized to the data, make sure all are actually outliers")

            est_poses, const_poses = est_poses[model.inlier_mask_], const_poses[model.inlier_mask_]
            self.debug ("Estimated stage model", model, "with an r2 score of", model.score(est_poses, const_poses),
                    ", classifying {}/{} constraints as outliers".format(np.sum(~model.inlier_mask_), len(self.constraints)))

            aligner.inliers = self.filter(model.inlier_mask_)
            aligner.outliers = self.filter(~model.inlier_mask_)
            #aligner.inliers = {pair for pair, inlier in zip(self.constraints.keys(), model.inlier_mask_) if inlier}
            #aligner.outliers = {pair for pair, inlier in zip(self.constraints.keys(), model.inlier_mask_) if not inlier}

        else:
            self.debug ("Estimated stage model", model, "with an r2 score of", model.score(est_poses, const_poses))

        if (aligner.model.predict([[0] * est_poses.shape[1]]).max() > const_poses.max() * 100 or 
                aligner.model.predict([[1] * est_poses.shape[1]]).max() > const_poses.max() * 100):
            warnings.warn("Stage model is predicting very large values for simple constraints,"
                " it may have hyperoptimized to the training data.")

        # calculate variance
        error = aligner.model.predict(est_poses) - const_poses
        error_thresh = np.percentile(np.abs(error), 99)
        self.debug ("Stage model error", np.percentile(np.abs(error), [0,5,50,75,95,100]).tolist(), error_thresh)
        aligner.error = error_thresh

        return aligner

    def solve(self, solver=None):
        """ Solve the constraints to get a global position for each image

        Args:
            solver (constitch.Solver): default constitch.LinearSolver()
                The solver class that is used to combine the overconstrainted
                system of constraints and optimize for the best global positions.
                More info can be found in constitch.solving

        Returns:
            The solver instance, with an attribute positions containing a dict
            mapping image indices to their global positions
        """
        from . import solving
        solver = solver or solving.LinearSolver()
        constraints = {}
        poses = {}
        for const in self:
            poses[const.index1] = const.box1.position
            poses[const.index2] = const.box2.position
            constraints[const.pair] = const

        newposes = solver.solve(constraints, poses)
        if type(newposes) == tuple:
            newposes, constraints = newposes
            pairs = set(constraints.keys())
            for pair in list(self.constraints.keys()):
                if pair not in pairs:
                    self._remove_single(pair)

        solver.positions = newposes

        return solver


    def _add_single(self, constraint):
        if len(self) != 0 and constraint.composite is not self.composite:
            raise ValueError("Adding constraints from different composite")

        if constraint.pair not in self.constraints or constraint.error <= self.constraints[constraint.pair].error:
            self.constraints[constraint.pair] = constraint
        return self.constraints[constraint.pair]

    def _remove_single(self, constraint):
        pair = constraint
        if isinstance(constraint, Constraint):
            if constraint is not self.constraints[constraint.pair]:
                raise ValueError("constraint is not in the set")
            pair = constraint.pair

        del self.constraints[pair]

    def _constraint_iter(self, constraints=None):
        constraints = constraints or self.constraints
        if isinstance(constraints, ConstraintSet):
            constraints = constraints.constraints
        if isinstance(constraints, dict):
            constraints = constraints.values()
        return constraints

    def _random_iter(self, constraints=None):
        constraints = list(self._constraint_iter(constraints))
        index = utils.lfsr(1, len(constraints))
        while index != 1:
            yield constraints[index-1]
            index = utils.lfsr(index, len(constraints))

    def _sorted_iter(self, constraints=None, sorted_by=None):
        constraints = self._constraint_iter(constraints)

        if type(sorted_by) == str:
            if sorted_by[0] == '-':
                sorted_by = lambda const: -getattr(const, sorted_by[1:])
            else:
                sorted_by = lambda const: getattr(const, sorted_by[1:])

        return sorted(constraints, key=sorted_by)


class ImplicitConstraintDict(dict):
    def __init__(self, composite, pairs_func):
        self.composite = composite
        self.pairs_func = pairs_func

    def keys(self):
        for pair in self.pairs_func():
            yield pair

    def values(self):
        for pair in self.pairs_func():
            yield self[pair]

    def items(self):
        for pair in self.pairs_func():
            yield pair, self[pair]

    def __getitem__(self, pair):
        return Constraint(self.composite, index1=pair[0], index2=pair[1])



"""
composite = constitch.CompositeImage()
composite.add_images(images, poses)

overlapping = composite.newconstraints(min_overlap=0.1)
constraints = overlapping.calculate()
constraints.remove(min_score=0.5, min_overlap=0.1)
modeled_constraints = overlapping.calculate(constraints.fit_model(remove_outliers=True))

constraints = composite.newconstraints(min_overlap=0.1).calculate(constitch.FFTAligner())
constraints.remove(min_score=0.5, min_overlap=0.1)
constraints.model(

constraints.calculate(constitch.FFTAligner())
constraints.filter(constraints.score < 0.5)
constraints.solve(constitch.OutlierSolver())

composite.apply(constraints.solve())
composite.stitch()




composite = constitch.CompositeImage(images, poses)

overlapping = composite.constraints(min_overlap=0.1)
constraints = overlapping.calculate(constitch.FFTAligner())
constraints = constraints.filter(min_score=0.5, min_overlap=0.1, max_length=max(images.shape))

stage_model = constraints.fit_model()
constraints = constraints.filter(stage_model.inliers)
modeled = overlapping.calculate(stage_model)

constraints = constraints.merge(modeled)
composite.apply(constraints.solve())

solver = constitch.LinearSolver()
composite.apply(solver.solve(constraints, modeled, overlapping))

composite.apply(constraints.solve(modeled, overlapping))
constraints = overlapping.merge(modeled).merge(constraints)
composite.apply(constraints.solve())

constraints.remove(min_score=0.5, min_overlap=0.1)
modeled_constraints = overlapping.calculate(constraints.fit_model(remove_outliers=True))

constraints = composite.newconstraints(min_overlap=0.1).calculate(constitch.FFTAligner())
constraints.remove(min_score=0.5, min_overlap=0.1)
constraints.model(

constraints.calculate(constitch.FFTAligner())
constraints.filter(constraints.score < 0.5)
constraints.solve(constitch.OutlierSolver())

composite.apply(constraints.solve())
composite.stitch()

#"""
